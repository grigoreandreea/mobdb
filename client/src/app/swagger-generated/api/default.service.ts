/**
 * ORDS generated API for AUTOR
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AUTORITEM } from '../model/aUTORITEM';
import { BIBLIOTECARITEM } from '../model/bIBLIOTECARITEM';
import { CARTEITEM } from '../model/cARTEITEM';
import { CATEGORIEITEM } from '../model/cATEGORIEITEM';
import { CITITORITEM } from '../model/cITITORITEM';
import { COMANDAITEM } from '../model/cOMANDAITEM';
import { DONATORITEM } from '../model/dONATORITEM';
import { DONEAZAITEM } from '../model/dONEAZAITEM';
import { EMITEITEM } from '../model/eMITEITEM';
import { FORMATADINITEM } from '../model/fORMATADINITEM';
import { FURNIZORITEM } from '../model/fURNIZORITEM';
import { IMPRUMUTAITEM } from '../model/iMPRUMUTAITEM';
import { LEGITIMATIEITEM } from '../model/lEGITIMATIEITEM';
import { PERSONALACHIZITIIITEM } from '../model/pERSONALACHIZITIIITEM';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = 'http://127.0.0.1:8080/ords/oltpmodbd';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     *
     * Create new records on AUTOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autorBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public autorBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public autorBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public autorBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling autorBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/autor/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from AUTOR
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autorGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public autorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public autorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public autorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/autor`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from AUTOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autorIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<AUTORITEM>;
    public autorIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AUTORITEM>>;
    public autorIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AUTORITEM>>;
    public autorIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling autorIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<AUTORITEM>(`${this.basePath}/autor/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from AUTOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autorIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<AUTORITEM>;
    public autorIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AUTORITEM>>;
    public autorIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AUTORITEM>>;
    public autorIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling autorIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AUTORITEM>(`${this.basePath}/autor/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on AUTOR
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autorIdPut(id: string, payload: AUTORITEM, observe?: 'body', reportProgress?: boolean): Observable<AUTORITEM>;
    public autorIdPut(id: string, payload: AUTORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AUTORITEM>>;
    public autorIdPut(id: string, payload: AUTORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AUTORITEM>>;
    public autorIdPut(id: string, payload: AUTORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling autorIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling autorIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<AUTORITEM>(`${this.basePath}/autor/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on AUTOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autorPost(payload: AUTORITEM, observe?: 'body', reportProgress?: boolean): Observable<AUTORITEM>;
    public autorPost(payload: AUTORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AUTORITEM>>;
    public autorPost(payload: AUTORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AUTORITEM>>;
    public autorPost(payload: AUTORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling autorPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<AUTORITEM>(`${this.basePath}/autor`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on BIBLIOTECAR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bibliotecarBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public bibliotecarBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public bibliotecarBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public bibliotecarBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling bibliotecarBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/bibliotecar/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from BIBLIOTECAR
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bibliotecarGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public bibliotecarGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public bibliotecarGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public bibliotecarGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/bibliotecar`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from BIBLIOTECAR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bibliotecarIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<BIBLIOTECARITEM>;
    public bibliotecarIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BIBLIOTECARITEM>>;
    public bibliotecarIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BIBLIOTECARITEM>>;
    public bibliotecarIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling bibliotecarIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<BIBLIOTECARITEM>(`${this.basePath}/bibliotecar/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from BIBLIOTECAR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bibliotecarIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<BIBLIOTECARITEM>;
    public bibliotecarIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BIBLIOTECARITEM>>;
    public bibliotecarIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BIBLIOTECARITEM>>;
    public bibliotecarIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling bibliotecarIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BIBLIOTECARITEM>(`${this.basePath}/bibliotecar/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on BIBLIOTECAR
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bibliotecarIdPut(id: string, payload: BIBLIOTECARITEM, observe?: 'body', reportProgress?: boolean): Observable<BIBLIOTECARITEM>;
    public bibliotecarIdPut(id: string, payload: BIBLIOTECARITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BIBLIOTECARITEM>>;
    public bibliotecarIdPut(id: string, payload: BIBLIOTECARITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BIBLIOTECARITEM>>;
    public bibliotecarIdPut(id: string, payload: BIBLIOTECARITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling bibliotecarIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling bibliotecarIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<BIBLIOTECARITEM>(`${this.basePath}/bibliotecar/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on BIBLIOTECAR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bibliotecarPost(payload: BIBLIOTECARITEM, observe?: 'body', reportProgress?: boolean): Observable<BIBLIOTECARITEM>;
    public bibliotecarPost(payload: BIBLIOTECARITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BIBLIOTECARITEM>>;
    public bibliotecarPost(payload: BIBLIOTECARITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BIBLIOTECARITEM>>;
    public bibliotecarPost(payload: BIBLIOTECARITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling bibliotecarPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<BIBLIOTECARITEM>(`${this.basePath}/bibliotecar`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on CARTE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public carteBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public carteBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public carteBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public carteBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling carteBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/carte/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from CARTE
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public carteGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public carteGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public carteGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public carteGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/carte`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from CARTE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public carteIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<CARTEITEM>;
    public carteIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CARTEITEM>>;
    public carteIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CARTEITEM>>;
    public carteIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling carteIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<CARTEITEM>(`${this.basePath}/carte/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from CARTE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public carteIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<CARTEITEM>;
    public carteIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CARTEITEM>>;
    public carteIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CARTEITEM>>;
    public carteIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling carteIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CARTEITEM>(`${this.basePath}/carte/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on CARTE
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public carteIdPut(id: string, payload: CARTEITEM, observe?: 'body', reportProgress?: boolean): Observable<CARTEITEM>;
    public carteIdPut(id: string, payload: CARTEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CARTEITEM>>;
    public carteIdPut(id: string, payload: CARTEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CARTEITEM>>;
    public carteIdPut(id: string, payload: CARTEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling carteIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling carteIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<CARTEITEM>(`${this.basePath}/carte/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on CARTE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cartePost(payload: CARTEITEM, observe?: 'body', reportProgress?: boolean): Observable<CARTEITEM>;
    public cartePost(payload: CARTEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CARTEITEM>>;
    public cartePost(payload: CARTEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CARTEITEM>>;
    public cartePost(payload: CARTEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling cartePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CARTEITEM>(`${this.basePath}/carte`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on CATEGORIE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categorieBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public categorieBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public categorieBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public categorieBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling categorieBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/categorie/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from CATEGORIE
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categorieGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public categorieGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public categorieGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public categorieGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/categorie`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from CATEGORIE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categorieIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<CATEGORIEITEM>;
    public categorieIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CATEGORIEITEM>>;
    public categorieIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CATEGORIEITEM>>;
    public categorieIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling categorieIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<CATEGORIEITEM>(`${this.basePath}/categorie/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from CATEGORIE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categorieIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<CATEGORIEITEM>;
    public categorieIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CATEGORIEITEM>>;
    public categorieIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CATEGORIEITEM>>;
    public categorieIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling categorieIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CATEGORIEITEM>(`${this.basePath}/categorie/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on CATEGORIE
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categorieIdPut(id: string, payload: CATEGORIEITEM, observe?: 'body', reportProgress?: boolean): Observable<CATEGORIEITEM>;
    public categorieIdPut(id: string, payload: CATEGORIEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CATEGORIEITEM>>;
    public categorieIdPut(id: string, payload: CATEGORIEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CATEGORIEITEM>>;
    public categorieIdPut(id: string, payload: CATEGORIEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling categorieIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling categorieIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<CATEGORIEITEM>(`${this.basePath}/categorie/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on CATEGORIE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public categoriePost(payload: CATEGORIEITEM, observe?: 'body', reportProgress?: boolean): Observable<CATEGORIEITEM>;
    public categoriePost(payload: CATEGORIEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CATEGORIEITEM>>;
    public categoriePost(payload: CATEGORIEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CATEGORIEITEM>>;
    public categoriePost(payload: CATEGORIEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling categoriePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CATEGORIEITEM>(`${this.basePath}/categorie`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on CITITOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cititorBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public cititorBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public cititorBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public cititorBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling cititorBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/cititor/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from CITITOR
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cititorGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public cititorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public cititorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public cititorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/cititor`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from CITITOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cititorIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<CITITORITEM>;
    public cititorIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CITITORITEM>>;
    public cititorIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CITITORITEM>>;
    public cititorIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cititorIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<CITITORITEM>(`${this.basePath}/cititor/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from CITITOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cititorIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<CITITORITEM>;
    public cititorIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CITITORITEM>>;
    public cititorIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CITITORITEM>>;
    public cititorIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cititorIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CITITORITEM>(`${this.basePath}/cititor/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on CITITOR
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cititorIdPut(id: string, payload: CITITORITEM, observe?: 'body', reportProgress?: boolean): Observable<CITITORITEM>;
    public cititorIdPut(id: string, payload: CITITORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CITITORITEM>>;
    public cititorIdPut(id: string, payload: CITITORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CITITORITEM>>;
    public cititorIdPut(id: string, payload: CITITORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cititorIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling cititorIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<CITITORITEM>(`${this.basePath}/cititor/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on CITITOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cititorPost(payload: CITITORITEM, observe?: 'body', reportProgress?: boolean): Observable<CITITORITEM>;
    public cititorPost(payload: CITITORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CITITORITEM>>;
    public cititorPost(payload: CITITORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CITITORITEM>>;
    public cititorPost(payload: CITITORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling cititorPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CITITORITEM>(`${this.basePath}/cititor`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on COMANDA
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public comandaBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public comandaBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public comandaBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public comandaBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling comandaBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/comanda/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from COMANDA
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public comandaGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public comandaGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public comandaGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public comandaGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/comanda`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from COMANDA
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public comandaIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<COMANDAITEM>;
    public comandaIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<COMANDAITEM>>;
    public comandaIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<COMANDAITEM>>;
    public comandaIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling comandaIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<COMANDAITEM>(`${this.basePath}/comanda/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from COMANDA
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public comandaIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<COMANDAITEM>;
    public comandaIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<COMANDAITEM>>;
    public comandaIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<COMANDAITEM>>;
    public comandaIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling comandaIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<COMANDAITEM>(`${this.basePath}/comanda/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on COMANDA
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public comandaIdPut(id: string, payload: COMANDAITEM, observe?: 'body', reportProgress?: boolean): Observable<COMANDAITEM>;
    public comandaIdPut(id: string, payload: COMANDAITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<COMANDAITEM>>;
    public comandaIdPut(id: string, payload: COMANDAITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<COMANDAITEM>>;
    public comandaIdPut(id: string, payload: COMANDAITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling comandaIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling comandaIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<COMANDAITEM>(`${this.basePath}/comanda/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on COMANDA
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public comandaPost(payload: COMANDAITEM, observe?: 'body', reportProgress?: boolean): Observable<COMANDAITEM>;
    public comandaPost(payload: COMANDAITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<COMANDAITEM>>;
    public comandaPost(payload: COMANDAITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<COMANDAITEM>>;
    public comandaPost(payload: COMANDAITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling comandaPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<COMANDAITEM>(`${this.basePath}/comanda`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on DONATOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public donatorBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public donatorBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public donatorBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public donatorBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling donatorBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/donator/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from DONATOR
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public donatorGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public donatorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public donatorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public donatorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/donator`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from DONATOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public donatorIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<DONATORITEM>;
    public donatorIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONATORITEM>>;
    public donatorIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONATORITEM>>;
    public donatorIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling donatorIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<DONATORITEM>(`${this.basePath}/donator/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from DONATOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public donatorIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<DONATORITEM>;
    public donatorIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONATORITEM>>;
    public donatorIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONATORITEM>>;
    public donatorIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling donatorIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<DONATORITEM>(`${this.basePath}/donator/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on DONATOR
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public donatorIdPut(id: string, payload: DONATORITEM, observe?: 'body', reportProgress?: boolean): Observable<DONATORITEM>;
    public donatorIdPut(id: string, payload: DONATORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONATORITEM>>;
    public donatorIdPut(id: string, payload: DONATORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONATORITEM>>;
    public donatorIdPut(id: string, payload: DONATORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling donatorIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling donatorIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<DONATORITEM>(`${this.basePath}/donator/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on DONATOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public donatorPost(payload: DONATORITEM, observe?: 'body', reportProgress?: boolean): Observable<DONATORITEM>;
    public donatorPost(payload: DONATORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONATORITEM>>;
    public donatorPost(payload: DONATORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONATORITEM>>;
    public donatorPost(payload: DONATORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling donatorPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DONATORITEM>(`${this.basePath}/donator`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on DONEAZA
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public doneazaBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public doneazaBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public doneazaBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public doneazaBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling doneazaBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/doneaza/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from DONEAZA
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public doneazaGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public doneazaGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public doneazaGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public doneazaGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/doneaza`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from DONEAZA
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public doneazaIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<DONEAZAITEM>;
    public doneazaIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONEAZAITEM>>;
    public doneazaIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONEAZAITEM>>;
    public doneazaIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling doneazaIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<DONEAZAITEM>(`${this.basePath}/doneaza/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from DONEAZA
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public doneazaIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<DONEAZAITEM>;
    public doneazaIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONEAZAITEM>>;
    public doneazaIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONEAZAITEM>>;
    public doneazaIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling doneazaIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<DONEAZAITEM>(`${this.basePath}/doneaza/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on DONEAZA
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public doneazaIdPut(id: string, payload: DONEAZAITEM, observe?: 'body', reportProgress?: boolean): Observable<DONEAZAITEM>;
    public doneazaIdPut(id: string, payload: DONEAZAITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONEAZAITEM>>;
    public doneazaIdPut(id: string, payload: DONEAZAITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONEAZAITEM>>;
    public doneazaIdPut(id: string, payload: DONEAZAITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling doneazaIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling doneazaIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<DONEAZAITEM>(`${this.basePath}/doneaza/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on DONEAZA
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public doneazaPost(payload: DONEAZAITEM, observe?: 'body', reportProgress?: boolean): Observable<DONEAZAITEM>;
    public doneazaPost(payload: DONEAZAITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DONEAZAITEM>>;
    public doneazaPost(payload: DONEAZAITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DONEAZAITEM>>;
    public doneazaPost(payload: DONEAZAITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling doneazaPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DONEAZAITEM>(`${this.basePath}/doneaza`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on EMITE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public emiteBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public emiteBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public emiteBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public emiteBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling emiteBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/emite/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from EMITE
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public emiteGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public emiteGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public emiteGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public emiteGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/emite`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from EMITE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public emiteIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<EMITEITEM>;
    public emiteIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EMITEITEM>>;
    public emiteIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EMITEITEM>>;
    public emiteIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling emiteIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<EMITEITEM>(`${this.basePath}/emite/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from EMITE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public emiteIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<EMITEITEM>;
    public emiteIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EMITEITEM>>;
    public emiteIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EMITEITEM>>;
    public emiteIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling emiteIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<EMITEITEM>(`${this.basePath}/emite/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on EMITE
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public emiteIdPut(id: string, payload: EMITEITEM, observe?: 'body', reportProgress?: boolean): Observable<EMITEITEM>;
    public emiteIdPut(id: string, payload: EMITEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EMITEITEM>>;
    public emiteIdPut(id: string, payload: EMITEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EMITEITEM>>;
    public emiteIdPut(id: string, payload: EMITEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling emiteIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling emiteIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<EMITEITEM>(`${this.basePath}/emite/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on EMITE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public emitePost(payload: EMITEITEM, observe?: 'body', reportProgress?: boolean): Observable<EMITEITEM>;
    public emitePost(payload: EMITEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EMITEITEM>>;
    public emitePost(payload: EMITEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EMITEITEM>>;
    public emitePost(payload: EMITEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling emitePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<EMITEITEM>(`${this.basePath}/emite`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on FORMATA_DIN
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public formataDinBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public formataDinBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public formataDinBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public formataDinBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling formataDinBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/formata_din/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from FORMATA_DIN
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public formataDinGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public formataDinGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public formataDinGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public formataDinGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/formata_din`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from FORMATA_DIN
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public formataDinIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<FORMATADINITEM>;
    public formataDinIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FORMATADINITEM>>;
    public formataDinIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FORMATADINITEM>>;
    public formataDinIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling formataDinIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FORMATADINITEM>(`${this.basePath}/formata_din/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from FORMATA_DIN
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public formataDinIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<FORMATADINITEM>;
    public formataDinIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FORMATADINITEM>>;
    public formataDinIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FORMATADINITEM>>;
    public formataDinIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling formataDinIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FORMATADINITEM>(`${this.basePath}/formata_din/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on FORMATA_DIN
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public formataDinIdPut(id: string, payload: FORMATADINITEM, observe?: 'body', reportProgress?: boolean): Observable<FORMATADINITEM>;
    public formataDinIdPut(id: string, payload: FORMATADINITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FORMATADINITEM>>;
    public formataDinIdPut(id: string, payload: FORMATADINITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FORMATADINITEM>>;
    public formataDinIdPut(id: string, payload: FORMATADINITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling formataDinIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling formataDinIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FORMATADINITEM>(`${this.basePath}/formata_din/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on FORMATA_DIN
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public formataDinPost(payload: FORMATADINITEM, observe?: 'body', reportProgress?: boolean): Observable<FORMATADINITEM>;
    public formataDinPost(payload: FORMATADINITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FORMATADINITEM>>;
    public formataDinPost(payload: FORMATADINITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FORMATADINITEM>>;
    public formataDinPost(payload: FORMATADINITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling formataDinPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FORMATADINITEM>(`${this.basePath}/formata_din`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on FURNIZOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public furnizorBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public furnizorBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public furnizorBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public furnizorBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling furnizorBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/furnizor/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from FURNIZOR
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public furnizorGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public furnizorGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public furnizorGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public furnizorGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/furnizor`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from FURNIZOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public furnizorIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<FURNIZORITEM>;
    public furnizorIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FURNIZORITEM>>;
    public furnizorIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FURNIZORITEM>>;
    public furnizorIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling furnizorIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FURNIZORITEM>(`${this.basePath}/furnizor/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from FURNIZOR
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public furnizorIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<FURNIZORITEM>;
    public furnizorIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FURNIZORITEM>>;
    public furnizorIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FURNIZORITEM>>;
    public furnizorIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling furnizorIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FURNIZORITEM>(`${this.basePath}/furnizor/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on FURNIZOR
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public furnizorIdPut(id: string, payload: FURNIZORITEM, observe?: 'body', reportProgress?: boolean): Observable<FURNIZORITEM>;
    public furnizorIdPut(id: string, payload: FURNIZORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FURNIZORITEM>>;
    public furnizorIdPut(id: string, payload: FURNIZORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FURNIZORITEM>>;
    public furnizorIdPut(id: string, payload: FURNIZORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling furnizorIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling furnizorIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FURNIZORITEM>(`${this.basePath}/furnizor/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on FURNIZOR
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public furnizorPost(payload: FURNIZORITEM, observe?: 'body', reportProgress?: boolean): Observable<FURNIZORITEM>;
    public furnizorPost(payload: FURNIZORITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FURNIZORITEM>>;
    public furnizorPost(payload: FURNIZORITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FURNIZORITEM>>;
    public furnizorPost(payload: FURNIZORITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling furnizorPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FURNIZORITEM>(`${this.basePath}/furnizor`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on IMPRUMUTA
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imprumutaBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public imprumutaBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public imprumutaBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public imprumutaBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling imprumutaBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/imprumuta/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from IMPRUMUTA
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imprumutaGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public imprumutaGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public imprumutaGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public imprumutaGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/imprumuta`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from IMPRUMUTA
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imprumutaIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<IMPRUMUTAITEM>;
    public imprumutaIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IMPRUMUTAITEM>>;
    public imprumutaIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IMPRUMUTAITEM>>;
    public imprumutaIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling imprumutaIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<IMPRUMUTAITEM>(`${this.basePath}/imprumuta/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from IMPRUMUTA
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imprumutaIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<IMPRUMUTAITEM>;
    public imprumutaIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IMPRUMUTAITEM>>;
    public imprumutaIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IMPRUMUTAITEM>>;
    public imprumutaIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling imprumutaIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<IMPRUMUTAITEM>(`${this.basePath}/imprumuta/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on IMPRUMUTA
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imprumutaIdPut(id: string, payload: IMPRUMUTAITEM, observe?: 'body', reportProgress?: boolean): Observable<IMPRUMUTAITEM>;
    public imprumutaIdPut(id: string, payload: IMPRUMUTAITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IMPRUMUTAITEM>>;
    public imprumutaIdPut(id: string, payload: IMPRUMUTAITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IMPRUMUTAITEM>>;
    public imprumutaIdPut(id: string, payload: IMPRUMUTAITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling imprumutaIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling imprumutaIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<IMPRUMUTAITEM>(`${this.basePath}/imprumuta/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on IMPRUMUTA
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public imprumutaPost(payload: IMPRUMUTAITEM, observe?: 'body', reportProgress?: boolean): Observable<IMPRUMUTAITEM>;
    public imprumutaPost(payload: IMPRUMUTAITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IMPRUMUTAITEM>>;
    public imprumutaPost(payload: IMPRUMUTAITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IMPRUMUTAITEM>>;
    public imprumutaPost(payload: IMPRUMUTAITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling imprumutaPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<IMPRUMUTAITEM>(`${this.basePath}/imprumuta`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on LEGITIMATIE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public legitimatieBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public legitimatieBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public legitimatieBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public legitimatieBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling legitimatieBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/legitimatie/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from LEGITIMATIE
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public legitimatieGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public legitimatieGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public legitimatieGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public legitimatieGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/legitimatie`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from LEGITIMATIE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public legitimatieIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<LEGITIMATIEITEM>;
    public legitimatieIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LEGITIMATIEITEM>>;
    public legitimatieIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LEGITIMATIEITEM>>;
    public legitimatieIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling legitimatieIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<LEGITIMATIEITEM>(`${this.basePath}/legitimatie/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from LEGITIMATIE
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public legitimatieIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<LEGITIMATIEITEM>;
    public legitimatieIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LEGITIMATIEITEM>>;
    public legitimatieIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LEGITIMATIEITEM>>;
    public legitimatieIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling legitimatieIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LEGITIMATIEITEM>(`${this.basePath}/legitimatie/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on LEGITIMATIE
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public legitimatieIdPut(id: string, payload: LEGITIMATIEITEM, observe?: 'body', reportProgress?: boolean): Observable<LEGITIMATIEITEM>;
    public legitimatieIdPut(id: string, payload: LEGITIMATIEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LEGITIMATIEITEM>>;
    public legitimatieIdPut(id: string, payload: LEGITIMATIEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LEGITIMATIEITEM>>;
    public legitimatieIdPut(id: string, payload: LEGITIMATIEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling legitimatieIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling legitimatieIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<LEGITIMATIEITEM>(`${this.basePath}/legitimatie/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on LEGITIMATIE
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public legitimatiePost(payload: LEGITIMATIEITEM, observe?: 'body', reportProgress?: boolean): Observable<LEGITIMATIEITEM>;
    public legitimatiePost(payload: LEGITIMATIEITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LEGITIMATIEITEM>>;
    public legitimatiePost(payload: LEGITIMATIEITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LEGITIMATIEITEM>>;
    public legitimatiePost(payload: LEGITIMATIEITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling legitimatiePost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<LEGITIMATIEITEM>(`${this.basePath}/legitimatie`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create new records on PERSONAL_ACHIZITII
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public personalAchizitiiBatchloadPost(payload: any, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public personalAchizitiiBatchloadPost(payload: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public personalAchizitiiBatchloadPost(payload: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public personalAchizitiiBatchloadPost(payload: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling personalAchizitiiBatchloadPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/personal_achizitii/batchload`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve records from PERSONAL_ACHIZITII
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public personalAchizitiiGet(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public personalAchizitiiGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public personalAchizitiiGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public personalAchizitiiGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/personal_achizitii`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Remove a record from PERSONAL_ACHIZITII
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public personalAchizitiiIdDelete(id: string, observe?: 'body', reportProgress?: boolean): Observable<PERSONALACHIZITIIITEM>;
    public personalAchizitiiIdDelete(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiIdDelete(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling personalAchizitiiIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<PERSONALACHIZITIIITEM>(`${this.basePath}/personal_achizitii/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Retrieve a record from PERSONAL_ACHIZITII
     * @param id implicit
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public personalAchizitiiIdGet(id: string, observe?: 'body', reportProgress?: boolean): Observable<PERSONALACHIZITIIITEM>;
    public personalAchizitiiIdGet(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiIdGet(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiIdGet(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling personalAchizitiiIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PERSONALACHIZITIIITEM>(`${this.basePath}/personal_achizitii/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create or update a record on PERSONAL_ACHIZITII
     * @param id implicit
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public personalAchizitiiIdPut(id: string, payload: PERSONALACHIZITIIITEM, observe?: 'body', reportProgress?: boolean): Observable<PERSONALACHIZITIIITEM>;
    public personalAchizitiiIdPut(id: string, payload: PERSONALACHIZITIIITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiIdPut(id: string, payload: PERSONALACHIZITIIITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiIdPut(id: string, payload: PERSONALACHIZITIIITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling personalAchizitiiIdPut.');
        }

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling personalAchizitiiIdPut.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<PERSONALACHIZITIIITEM>(`${this.basePath}/personal_achizitii/${encodeURIComponent(String(id))}`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     *
     * Create a new record on PERSONAL_ACHIZITII
     * @param payload
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public personalAchizitiiPost(payload: PERSONALACHIZITIIITEM, observe?: 'body', reportProgress?: boolean): Observable<PERSONALACHIZITIIITEM>;
    public personalAchizitiiPost(payload: PERSONALACHIZITIIITEM, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiPost(payload: PERSONALACHIZITIIITEM, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PERSONALACHIZITIIITEM>>;
    public personalAchizitiiPost(payload: PERSONALACHIZITIIITEM, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling personalAchizitiiPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PERSONALACHIZITIIITEM>(`${this.basePath}/personal_achizitii`,
            payload,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
